classdef FeaturizerSynthetic < Wrapper & Configurable
  %FEATURIZERSYNTHETIC Adds a synthetic featurization to a discrete environment.
  %
  %   A wrapper environment that adds a synthetic featurization to the
  %   discrete contained environment, thus turning it into a
  %   continuous-valued one. Either or both of the observation space and
  %   the action space can be featurized. Both are featurized in terms of
  %   Gaussian radial basis functions (RBF).
  %
  %   For the observation space, a Gaussian RBF phi_o in an R^n space is
  %   synthesized for each discrete observation o. When the contained
  %   environment emits an observation o, an n-dimensional
  %   continuous-valued feature vector is generated by sampling it from the
  %   associated RBF phi_o.
  %
  %   For the action space, a Gaussian RBF psi_a in an R^m space is
  %   synthesized for each discrete action a. If the contained environment
  %   is not using action lists, then when a continuous-valued action (with
  %   m dimensions) is received from outside, it will be mapped to a
  %   discrete action with the probability of action a being proportional
  %   to the strength of the receptive field of the basis function psi_a.
  %   If the contained environment is using action lists, then a discrete
  %   action row in the actions matrix denoting action a (an index vector
  %   having 1 at position a) will be mapped into a continuous action row
  %   by sampling from the associated basis function psi_a; in effect, each
  %   state-action will get a feature representation in a single
  %   m-dimensional real-valued space, thus causing generalization over
  %   actions to occur.
  %
  %   Truncation can be enabled for either or both of the observation and
  %   action spaces. With truncation, each outgoing continuous-valued
  %   vector (observations and the rows of the actions matrix) is processed
  %   so that all elements are between 0 and 1 (inclusive). More precisely,
  %   all elements are truncated to the range [-1,1] and then mapped to the
  %   range [0,1]. This process amplifies the probability of exact zeros
  %   and ones and can introduce additional aliasing. The amount of
  %   truncation depends on the oSynthVarShape and aSynthVarShape
  %   parameters: smaller shape values cause less of the vector elements to
  %   be outside the range [-1,1]. With action space truncation and when
  %   not using action lists, a similar operation is performed for each
  %   incoming action vector before mapping it to a discrete action: all
  %   elements are truncated to the range [0,1] and then mapped to the
  %   range [-1,1].
  %
  %
  %   The synthesizing distributions
  %
  %   The mean of each observation and action basis function (phi_o and
  %   psi_a) is synthesized by sampling from a zero-mean and unit-variance
  %   Gaussian distribution (the mean-synthetizing distribution).
  %
  %   If the contained environment is a GraphSynthetic environment, it is
  %   possible to have the observation featurization to respect its
  %   neighborhood grid structure, so that locality is preserved. This is
  %   enabled with the useContainedGrid flag. In this case, the dimension
  %   of the observation space will be set to match the dimension of the
  %   observation neighborhood grid of the contained GraphSynthetic
  %   environment. The mean of the observation basis function for
  %   observation o is then synthesized by sampling from a
  %   mean-synthesizing distribution that is centered not at the origin but
  %   at the grid position of observation o, with the grid first being
  %   normalized to fit the unit cube. In this case, the variance of the
  %   mean-synthetizing distribution defaults to the normalized node
  %   spacing of the grid, but it can be changed with oSynthMeanVar.
  %
  %   The variance of each observation and action basis function (phi_o and
  %   psi_a) is synthesized by sampling the diagonal of the variance matrix
  %   from a unit-scale gamma distribution (the variance-synthetizing
  %   distribution). The shape (mean) of the variance-synthetizing
  %   distributions can be set with oSynthVarShape and aSynthVarShape for
  %   the observation and action spaces, respectively. These metaparameters
  %   control the expected overlap of the actual observation and action
  %   basis functions.
  %
  %
  %   Note: The FeaturizerSynthetic.filterAction() method is completely
  %   untested! This method is used for processing actions with
  %   environments that do not use action lists.
  
  % TODO re-think and implement after possibly re-defining the Environment
  % props interpretation of action lists with continuous observations and
  % discrete actions; see Environment TODOs.
  %
  % [For the action list case, it is possible to have generalization over
  % actions to be disabled. This is controlled with the
  % dontGeneralizeOverActions parameter. If set to true (no generalization
  % over actions), then the rows in the actions matrix are interpreted as
  % having a block structure with |A_c| blocks, with each block having
  % |O_c| elements (|A_c| and |O_c| denote the sizes of the action and
  % observation spaces of the contained environment, respectively). This
  % structure is then adjusted so as to have |A| blocks, with each block
  % having |O| elements  (|A| and |O| denote the sizes of the action and
  % observation spaces of this featurizer environment, respectively).]
  
  % TODO Replace the non-negative Gaussian (var-synthesizing) with a gamma
  % distribution. Don't use nans, but []'s.
  
  
  
  
  properties
    % User-configurable parameters
    
    % random seed used for synthesizing the environment
    synthSeed = 1;
    
    % Dimensions of the observation and action spaces. Either or both can
    % be set to [] to disable featurization of the corresponding space. If
    % useContainedGrid is used, then oDim must match the number of
    % observation dimensions of the contained grid.
    oDim = []; aDim = [];
    
    % Shape (mean) of the variance-synthetizing gamma distributions for the
    % observation and action spaces.
    %   (double)
    oSynthVarShape = 1; aSynthVarShape = 1;
    
    % Observation and action truncation flags.
    %   (logical)
    doTruncateO = false; doTruncateA = false;
    
    
    % If the contained environment environment is a GraphSynthetic
    % environment, then setting this to true will cause the observation
    % neighborhood grid to be respected while synthesizing the observation
    % basis functions. In this case, oDim must match the number of
    % observation dimensions of the contained grid.
    %   (logical)
    useContainedGrid = false;
    
    % Radial variance of the mean-synthesizing distributions from which the
    % observation featurization basis function means are synthesized. Set
    % to [] to use the default (see class help section). There is no reason
    % to set this unless useContainedGrid == true (if useContainedGrid ==
    % false, then this setting effectively controls the same thing as
    % oVar).
    %   (double)
    oSynthMeanVar = [];
    
  end
  properties (Constant, Hidden)
    oDim_t                   = @(x) (isempty(x) || (isscalar(x) && isnumeric(x) && round(x) == x && x >= 0));
    aDim_t                   = @(x) (isempty(x) || (isscalar(x) && isnumeric(x) && round(x) == x && x >= 0));
    oSynthVarShape_t         = @(x) (isscalar(x) && isnumeric(x) && x >= 0);
    aSynthVarShape_t         = @(x) (isscalar(x) && isnumeric(x) && x >= 0);
    doTruncateO_t            = @(x) (isscalar(x) && islogical(x));
    doTruncateA_t            = @(x) (isscalar(x) && islogical(x));
    useContainedGrid_t       = @(x) (isscalar(x) && islogical(x));
    oSynthMeanVar_t          = @(x) (isempty(x) || (isscalar(x) && isnumeric(x) && x >= 0));
  end
  properties (Constant, Hidden, Access=private)
    mandatoryArgs = {};
  end
  
  
  properties
    
    % Means and radial variances of the Gaussian RBFs for the observation
    % space. phiMean(o,:) and phiVar(o,:) define the mean and the diagonal
    % variance of the basis function corresponding to observation o.
    %   (double matrix)
    phiMean; phiVar;
    
    % Means and radial variances of the Gaussian RBFs for the action space.
    % See phiMean and phiVar.
    %   (column double array)
    psiMean; psiVar;
    
  end
  
  
  properties (Access=private)
    
    % environment properties
    props;
    
  end
  
  
  
  
  % Construction methods begin
  
  
  methods
    
    function this = FeaturizerSynthetic( varargin )
      % Constructor.
      % 
      %   this = FeaturizerSynthetic( <name/value pairs> ... )
      % 
      % The user-configurable class properties can be provided as
      % name/value pairs here during construction.
      
      % construct base class
      this@Wrapper( varargin{:} );
      
      % configure
      this.configure( varargin, this.mandatoryArgs );
      
    end
    
    
    function this = construct( this )
      % Late constructor.
      
      % construct the contained environment
      construct@Wrapper( this );
      
      
      % create a random stream, set to default stream (stats toolbox uses the default stream)
      prevRStream = RandStream.setGlobalStream( RandStream('mt19937ar', 'seed', this.synthSeed ) );
      
      % get properties of the contained environment
      ceProps = this.containedEnvironment.getProps();
      
      % check that spaces to be featurized are discrete
      assert( isempty(this.oDim) || ceProps.observationType == 'd', ...
        'Only a discrete observation space can be featurized.' );
      assert( isempty(this.aDim) || ceProps.actionType == 'd', ...
        'Only a discrete action space can be featurized.' );
      
      % check that useContainedGrid is used only for a GraphSynthetic
      % contained environment
      assert( ~this.useContainedGrid || isa( this.containedEnvironment, 'GraphSynthetic' ), ...
        'useContainedGrid can be used only in conjunction with a GraphSynthetic environment.' );
      
      % if the observation space is being processed and useContainedGrid is
      % used, then oDim must match the number of dimensions of the grid
      assert( isempty(this.oDim) || ( ~this.useContainedGrid || this.oDim == this.containedEnvironment.dimsPomdp ), ...
        'If useContainedGrid is used, then oDim must match the number of dimensions of the contained grid.' );
      
      
      % synthesize the observation basis functions
      if ~isempty(this.oDim)
        
        % set the mean values of the mean-synthesizing distributions (oSynthMeanMean)
        if ~this.useContainedGrid
          
          % use a zero-mean synthesizing distribution
          oSynthMeanMean = zeros( ceProps.observationDim, this.oDim );
          
        else
          
          % use the grid cells as mean values
          oSynthMeanMean = (this.containedEnvironment.oGridPos - 1) ./ (this.containedEnvironment.dimLength - 1);
          if isempty(oSynthMeanMean); oSynthMeanMean = 0; end   % should happen only if having just a single observation
          
        end
        
        % set the variance of the mean-synthesizing distributions, unless already given (this.oSynthMeanVar)
        if isempty(this.oSynthMeanVar)
          
          if this.useContainedGrid
            % set to normalized grid cell spacing
            this.oSynthMeanVar = 1 / (this.containedEnvironment.dimLength - 1);
            if isinf( this.oSynthMeanVar ); this.oSynthMeanVar = realmax; end
          else
            % no grid being used, just set to one
            this.oSynthMeanVar = 1;
          end
          
        end
        
        % synthesize the observation basis functions (phi_mean and phi_var) using:
        % oSynthMeanMean, this.oSynthMeanVar, this.oSynthVarShape
        this.phiMean = mvnrnd( oSynthMeanMean, repmat( this.oSynthMeanVar, 1, size(oSynthMeanMean,2) ) );
        this.phiVar = gamrnd( this.oSynthVarShape, 1, size(oSynthMeanMean) );
        
      end
      
      
      % synthesize the action basis functions
      if ~isempty(this.aDim)
        
        % set the mean values of the mean-synthesizing distributions (aSynthMeanMean)
        aSynthMeanMean = zeros( ceProps.actionDim, this.aDim );
        
        % synthesize the action basis functions (psi_mean and psi_var) using:
        % aSynthMeanMean, aSynthMeanVar = 1, this.aSynthVarShape
        this.psiMean = mvnrnd( aSynthMeanMean, ones(1, size(aSynthMeanMean,2)) );
        this.psiVar = gamrnd( this.aSynthVarShape, 1, size(aSynthMeanMean) );
        
      end
      
      
      % revert the global random stream
      RandStream.setGlobalStream( prevRStream );
      
      
      % define the properties struct that is visible to outside
      this.props = ceProps;   % start with the properties of the contained environment, don't touch useActionsList
      if ~isempty(this.oDim)
        this.props.observationType = 'c';
        this.props.observationDim = this.oDim;
      end
      if ~isempty(this.aDim)
        this.props.actionType = 'c';
        this.props.actionDim = this.aDim;
      end
      
    end
    
  end
  
  
  
  
  % method forward re-implementations begin
  
  
  methods
    
    % return the environment properties struct
    function props = getProps( this ); props = this.props; end
    
  end
  
  
  
  
  % observation and action filter hook re-implementations begin
  
  
  methods (Access=protected)
    
    function observation = filterObservation( this, observation )
      % This filter hook is called for translating an observation from the
      % contained environment to an observation to be sent out.
      
      % no-op if the observation space is not featurized or if the observation is empty (terminal state)
      if isempty(this.oDim) || isempty(observation); return; end
      
      % validate the observation: expect an index vector
      nz = nonzeros(observation);
      assert( length(nz) == 1 && nz == 1, ...
        'The contained environment should emit index vector observations.' );
      
      % convert to logical
      observation = logical(observation);
      
      % sample from the Gaussian phi_o
      prevRStream = RandStream.setGlobalStream( this.rstream );
      observation = mvnrnd( this.phiMean(observation,:), this.phiVar(observation,:) );
      RandStream.setGlobalStream( prevRStream );
      
      % truncate if requested
      if this.doTruncateO
        
        % truncate to the range [-1,1], then map to the range [0,1]
        observation = min( max( observation, -1 ), 1 );
        observation = (observation + 1) ./ 2;
        
      end
      
    end
    
    function action = filterAction( this, action )
      % This filter hook is called for translating an incoming action to an
      % action to be sent to the contained environment.
      
      % no-op if the action space is not featurized
      if isempty(this.aDim); return; end
      
      persistent RLCC_WARNED_FSFA;
      if isempty(RLCC_WARNED_FSFA)
        warning('The FeaturizerSynthetic.filterAction() method is completely untested!');
        RLCC_WARNED_FSFA = 1;
      end
      
      % truncate if requested
      if this.doTruncateA
        
        % truncate to the range [0,1], then map to the range [-1,1]
        action = min( max( action, 0 ), 1 );
        action = (2 * action) - 1;
        
      end
      
      % compute the probability density of each action basis function at the point specified by 'action'
      p = mvnpdf( action, this.psiMean, shiftdim( this.psiVar', -1 ) );
      
      % sample the action index from the distribution defined by the obtained density vector
      action = randDiscretePdf( this.rstream, p );
      
    end
    
    function actions = filterActionsMatrix( this, actions )
      % This filter hook is called for translating an actions matrix from the
      % contained environment to an actions matrix to be sent out.
      
      % no-op if the action space is not featurized or if the actions matrix is empty (terminal state)
      if isempty(this.aDim) || isempty(actions); return; end
      
      % validate the actions matrix: expect index vectors on rows (do just an approximate check)
      nz = nonzeros(actions);
      assert( length(nz) == size(actions, 1) && all(nz == 1), ...
        'The contained environment should emit actions matrices with index vector rows.' );
      
      % convert the matrix of index vector rows into an index number vector
      [i, j] = find(actions); [~, i] = sort(i); actions = j(i);
      
      % replace each row, each holding the action index a, with a sample from the Gaussian psi_a
      prevRStream = RandStream.setGlobalStream( this.rstream );
      actions = mvnrnd( this.psiMean(actions,:), shiftdim( this.psiVar(actions,:)', -1 ) );
      RandStream.setGlobalStream( prevRStream );
      
      % truncate if requested
      if this.doTruncateA
        
        % truncate elements to the range [-1,1], then map to the range [eps,1]
        actions = min( max( actions, -1 ), 1 );
        actions = (actions + 1) ./ 2;
        
      end
      
    end
    
  end
  
end
